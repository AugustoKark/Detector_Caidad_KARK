package altermarkive.guardian.detection

// Digital filters (low-pass & high-pass) generated by the code of A.J. Fisher, see:
// http://www-users.cs.york.ac.uk/~fisher/mkfilter/

import altermarkive.guardian.alerts.Alarm
import altermarkive.guardian.BuildConfig
import altermarkive.guardian.alerts.FallAlertActivity
import altermarkive.guardian.utils.Log
import altermarkive.guardian.core.Guardian
import altermarkive.guardian.sensors.Battery
import altermarkive.guardian.sensors.Positioning
import altermarkive.guardian.storage.ServerAdapter
import android.content.Context
import android.content.Context.SENSOR_SERVICE
import android.hardware.Sensor
import android.hardware.SensorEvent
import android.hardware.SensorEventListener
import android.hardware.SensorManager
import kotlin.math.sqrt
import kotlin.math.abs

class Detector private constructor() : SensorEventListener {
    var context: Guardian? = null

    companion object {
        internal var singleton: Detector = Detector()

        internal fun instance(context: Guardian): Detector {
            if (singleton.context != context) {
                singleton.initiateSensor(context)
            }
            return singleton
        }

        private val TAG: String = Detector::class.java.simpleName

        fun log(level: Int, entry: String) {
            if (BuildConfig.DEBUG) {
                Log.println(level, TAG, entry)
            }
        }

        internal const val INTERVAL_MS = 20  //Intervalo de muestreo: 20ms (50HZ)
        private const val DURATION_S = 10    //Duración de la ventana de muestreo: 10s
        internal const val N = DURATION_S * 1000 / INTERVAL_MS // Total de muestras en el buffer

        //Para la deteccion de caidas
        internal const val FALLING_WAIST_SV_TOT = 0.6  // Umbral para detectar la fase de caída libre
        internal const val IMPACT_WAIST_SV_TOT = 1.8  // Reducido para mayor sensibilidad
        internal const val IMPACT_WAIST_SV_D = 1.5     // Reducido para mayor sensibilidad
        internal const val IMPACT_WAIST_SV_MAX_MIN = 1.8  // Reducido
        internal const val IMPACT_WAIST_Z_2 = 1.2    // Reducido

        private const val SPAN_MAX_MIN = 100 / INTERVAL_MS
        private const val SPAN_FALLING = 1000 / INTERVAL_MS
        private const val SPAN_IMPACT = 2000 / INTERVAL_MS
        private const val SPAN_AVERAGING = 400 / INTERVAL_MS

        private const val FILTER_N_ZEROS = 2
        private const val FILTER_N_POLES = 2
        private const val FILTER_LPF_GAIN = 4.143204922e+03
        private const val FILTER_HPF_GAIN = 1.022463023e+00
        private const val FILTER_FACTOR_0 = -0.9565436765
        private const val FILTER_FACTOR_1 = +1.9555782403

        private const val G = 1.0

        private const val LYING_AVERAGE_Z_LPF = 0.5

        // Umbral para detectar posición horizontal
        private const val HORIZONTAL_THRESHOLD = 0.2  // Si Z < 0.2G, el dispositivo está casi horizontal

        internal const val BUFFER_X: Int = 0
        internal const val BUFFER_Y: Int = 1
        internal const val BUFFER_Z: Int = 2
        internal const val BUFFER_X_LPF: Int = 3
        internal const val BUFFER_Y_LPF: Int = 4
        internal const val BUFFER_Z_LPF: Int = 5
        internal const val BUFFER_X_HPF: Int = 6
        internal const val BUFFER_Y_HPF: Int = 7
        internal const val BUFFER_Z_HPF: Int = 8
        internal const val BUFFER_X_MAX_MIN: Int = 9
        internal const val BUFFER_Y_MAX_MIN: Int = 10
        internal const val BUFFER_Z_MAX_MIN: Int = 11
        internal const val BUFFER_SV_TOT: Int = 12
        internal const val BUFFER_SV_D: Int = 13
        internal const val BUFFER_SV_MAX_MIN: Int = 14
        internal const val BUFFER_Z_2: Int = 15
        internal const val BUFFER_FALLING: Int = 16
        internal const val BUFFER_IMPACT: Int = 17
        internal const val BUFFER_LYING: Int = 18
        internal const val BUFFER_COUNT: Int = 19
    }

    private var timeoutFalling: Int = -1
    private var timeoutImpact: Int = -1
    val buffers: Buffers = Buffers(BUFFER_COUNT, N, 0, Double.NaN)
    private val x: DoubleArray = buffers.buffers[BUFFER_X]   // Aceleracion en X
    private val y: DoubleArray = buffers.buffers[BUFFER_Y]   // Aceleracion en Y
    private val z: DoubleArray = buffers.buffers[BUFFER_Z]   // Aceleracion en Z
    private val xLPF: DoubleArray = buffers.buffers[BUFFER_X_LPF]   // Aceleracion en X (filtro pasa-bajos)
    private val yLPF: DoubleArray = buffers.buffers[BUFFER_Y_LPF]   // Aceleracion en Y (filtro pasa-bajos)
    private val zLPF: DoubleArray = buffers.buffers[BUFFER_Z_LPF]   // Aceleracion en Z (filtro pasa-bajos)
    private val xHPF: DoubleArray = buffers.buffers[BUFFER_X_HPF]   // Aceleracion en X (filtro pasa-altos)
    private val yHPF: DoubleArray = buffers.buffers[BUFFER_Y_HPF]   // Aceleracion en Y (filtro pasa-altos)
    private val zHPF: DoubleArray = buffers.buffers[BUFFER_Z_HPF]   // Aceleracion en Z (filtro pasa-altos)
    private val xMaxMin: DoubleArray = buffers.buffers[BUFFER_X_MAX_MIN]
    private val yMaxMin: DoubleArray = buffers.buffers[BUFFER_Y_MAX_MIN]
    private val zMaxMin: DoubleArray = buffers.buffers[BUFFER_Z_MAX_MIN]
    private val svTOT: DoubleArray = buffers.buffers[BUFFER_SV_TOT]
    private val svD: DoubleArray = buffers.buffers[BUFFER_SV_D]
    private val svMaxMin: DoubleArray = buffers.buffers[BUFFER_SV_MAX_MIN]
    private val z2: DoubleArray = buffers.buffers[BUFFER_Z_2]
    private val falling: DoubleArray = buffers.buffers[BUFFER_FALLING]
    private val impact: DoubleArray = buffers.buffers[BUFFER_IMPACT]
    private val lying: DoubleArray = buffers.buffers[BUFFER_LYING]
    private val xLpfXV = DoubleArray(FILTER_N_ZEROS + 1) { 0.0 }
    private val xLpfYV = DoubleArray(FILTER_N_POLES + 1) { 0.0 }
    private val yLpfXV = DoubleArray(FILTER_N_ZEROS + 1) { 0.0 }
    private val yLpfYV = DoubleArray(FILTER_N_POLES + 1) { 0.0 }
    private val zLpfXV = DoubleArray(FILTER_N_ZEROS + 1) { 0.0 }
    private val zLpfYV = DoubleArray(FILTER_N_POLES + 1) { 0.0 }
    private val xHpfXV = DoubleArray(FILTER_N_ZEROS + 1) { 0.0 }
    private val xHpfYV = DoubleArray(FILTER_N_POLES + 1) { 0.0 }
    private val yHpfXV = DoubleArray(FILTER_N_ZEROS + 1) { 0.0 }
    private val yHpfYV = DoubleArray(FILTER_N_POLES + 1) { 0.0 }
    private val zHpfXV = DoubleArray(FILTER_N_ZEROS + 1) { 0.0 }
    private val zHpfYV = DoubleArray(FILTER_N_POLES + 1) { 0.0 }
    private var anteX: Double = Double.NaN
    private var anteY: Double = Double.NaN
    private var anteZ: Double = Double.NaN
    private var anteTime: Long = 0
    private var regular: Long = 0

    // Variables para control de tiempo y falsos positivos
    private var beforeFallOrientation: Triple<Double, Double, Double>? = null
    private var afterFallOrientation: Triple<Double, Double, Double>? = null
    private var beforeInclinationAngle: Double? = null
    private var afterInclinationAngle: Double? = null
    private val ORIENTATION_THRESHOLD = 0.4  // Más sensible
    private var fallStartTime: Long = 0
    private var lastFallAlertTime: Long = 0  // Para evitar alertas repetidas

    // Variables para análisis de patrón
    private var peakAcceleration: Double = 0.0
    private var minAccelerationBeforePeak: Double = Double.MAX_VALUE
    private var consecutiveLowSVCount: Int = 0

    // Enum para tipos de caída
    private enum class FallType {
        FORWARD, BACKWARD, LEFT, RIGHT, UNKNOWN
    }

    private fun linear(before: Long, ante: Double, after: Long, post: Double, now: Long): Double {
        return ante + (post - ante) * (now - before).toDouble() / (after - before).toDouble()
    }

    @Suppress("SameParameterValue")
    private fun at(array: DoubleArray, index: Int, size: Int): Double {
        return array[(index + size) % size]
    }

    private fun expire(timeout: Int): Int {
        return if (timeout > -1) {
            timeout - 1
        } else {
            -1
        }
    }

    private fun sv(x: Double, y: Double, z: Double): Double {
        return sqrt(x * x + y * y + z * z)
    }

    private fun min(array: DoubleArray): Double {
        var min: Double = at(array, buffers.position, N)
        for (i: Int in 1 until SPAN_MAX_MIN) {
            val value: Double = at(array, buffers.position - i, N)
            if (!value.isNaN() && value < min) {
                min = value
            }
        }
        return min
    }

    private fun max(array: DoubleArray): Double {
        var max: Double = at(array, buffers.position, N)
        for (i: Int in 1 until SPAN_MAX_MIN) {
            val value: Double = at(array, buffers.position - i, N)
            if (!value.isNaN() && max < value) {
                max = value
            }
        }
        return max
    }

    // Low-pass Butterworth filter, 2nd order, 50 Hz sampling rate, corner frequency 0.25 Hz
    private fun lpf(value: Double, xv: DoubleArray, yv: DoubleArray): Double {
        xv[0] = xv[1]
        xv[1] = xv[2]
        xv[2] = value / FILTER_LPF_GAIN
        yv[0] = yv[1]
        yv[1] = yv[2]
        yv[2] = (xv[0] + xv[2]) + 2 * xv[1] + (FILTER_FACTOR_0 * yv[0]) + (FILTER_FACTOR_1 * yv[1])
        return yv[2]
    }

    // High-pass Butterworth filter, 2nd order, 50 Hz sampling rate, corner frequency 0.25 Hz
    private fun hpf(value: Double, xv: DoubleArray, yv: DoubleArray): Double {
        xv[0] = xv[1]
        xv[1] = xv[2]
        xv[2] = value / FILTER_HPF_GAIN
        yv[0] = yv[1]
        yv[1] = yv[2]
        yv[2] = (xv[0] + xv[2]) - 2 * xv[1] + (FILTER_FACTOR_0 * yv[0]) + (FILTER_FACTOR_1 * yv[1])
        return yv[2]
    }

    private fun isInHorizontalPosition(): Boolean {
        // Calcular el promedio del eje Z filtrado en los últimos 400ms
        var sumZ = 0.0
        var count = 0

        for (i in 0 until SPAN_AVERAGING) {
            val zVal = at(zLPF, buffers.position - i, N)
            if (!zVal.isNaN()) {
                sumZ += abs(zVal)
                count++
            }
        }

        if (count == 0) return false

        val avgZ = sumZ / count

        // Si el valor absoluto de Z es menor que el umbral, el dispositivo está horizontal
        val isHorizontal = avgZ < HORIZONTAL_THRESHOLD

        if (isHorizontal) {
            log(android.util.Log.DEBUG, "Device is in horizontal position - Z average: $avgZ")
        }

        return isHorizontal
    }

    private fun detectFallType(): FallType {
        val at = buffers.position

        // Analizar los últimos 500ms de datos
        var xPeak = 0.0
        var yPeak = 0.0
        var zDrop = 0.0
        var xMin = 0.0
        var yMin = 0.0

        for (i in 0 until 25) { // 500ms de datos
            val idx = (at - i + N) % N
            if (x[idx] > xPeak) xPeak = x[idx]
            if (y[idx] > yPeak) yPeak = y[idx]
            if (x[idx] < xMin) xMin = x[idx]
            if (y[idx] < yMin) yMin = y[idx]
            if (z[idx] < zDrop) zDrop = z[idx]
        }

        // Determinar tipo de caída basado en los patrones
        return when {
            abs(xPeak) > 1.2 && abs(xPeak) > abs(yPeak) -> {
                if (xPeak > 0) FallType.RIGHT else FallType.LEFT
            }
            abs(yPeak) > 1.2 && abs(yPeak) > abs(xPeak) -> {
                if (yPeak > 0) FallType.FORWARD else FallType.BACKWARD
            }
            else -> FallType.UNKNOWN
        }
    }

    private fun detectLateralFall(): Boolean {
        val at = buffers.position

        // En caídas laterales, típicamente:
        // - X (lateral) muestra un pico significativo
        // - Z (vertical) disminuye
        // - Y puede no cambiar mucho

        var xPeak = 0.0
        var zDrop = 0.0

        for (i in 0 until 25) { // 500ms de datos
            val idx = (at - i + N) % N
            if (abs(x[idx]) > abs(xPeak)) xPeak = x[idx]
            if (z[idx] < zDrop) zDrop = z[idx]
        }

        val isLateralFall = abs(xPeak) > 1.3 && zDrop < -0.3

        if (isLateralFall) {
            log(android.util.Log.DEBUG, "Lateral fall detected - X peak: $xPeak, Z drop: $zDrop")
        }

        return isLateralFall
    }

    private fun process() {
        val at: Int = buffers.position
        timeoutFalling = expire(timeoutFalling)
        timeoutImpact = expire(timeoutImpact)
        xLPF[at] = lpf(x[at], xLpfXV, xLpfYV)
        yLPF[at] = lpf(y[at], yLpfXV, yLpfYV)
        zLPF[at] = lpf(z[at], zLpfXV, zLpfYV)
        xHPF[at] = hpf(x[at], xHpfXV, xHpfYV)
        yHPF[at] = hpf(y[at], yHpfXV, yHpfYV)
        zHPF[at] = hpf(z[at], zHpfXV, zHpfYV)
        xMaxMin[at] = max(x) - min(x)
        yMaxMin[at] = max(y) - min(y)
        zMaxMin[at] = max(z) - min(z)
        val svTOTAt: Double = sv(x[at], y[at], z[at])
        svTOT[at] = svTOTAt
        val svDAt: Double = sv(xHPF[at], yHPF[at], zHPF[at])
        svD[at] = svDAt
        svMaxMin[at] = sv(xMaxMin[at], yMaxMin[at], zMaxMin[at])
        z2[at] = (svTOTAt * svTOTAt - svDAt * svDAt - G * G) / (2.0 * G)
        val svTOTBefore: Double = at(svTOT, at - 1, N)

        falling[at] = 0.0

        // Detección simple de caída libre
        if (FALLING_WAIST_SV_TOT <= svTOTBefore && svTOTAt < FALLING_WAIST_SV_TOT) {
            timeoutFalling = SPAN_FALLING
            falling[at] = 1.0
            fallStartTime = System.currentTimeMillis()
            minAccelerationBeforePeak = svTOTAt
            peakAcceleration = 0.0  // Reset para esta nueva caída
            captureOrientation(true)
            log(android.util.Log.DEBUG, "Fall detection started - svTOT: $svTOTAt")
        }

        impact[at] = 0.0
        if (-1 < timeoutFalling) {
            val svMaxMinAt: Double = svMaxMin[at]
            val z2At: Double = z2[at]

            // Guardar la aceleración máxima
            if (svTOTAt > peakAcceleration) {
                peakAcceleration = svTOTAt
            }

            // Detectar tipo de caída
            val fallType = detectFallType()
            val isLateralFall = fallType == FallType.LEFT || fallType == FallType.RIGHT

            // Umbrales más sensibles
            val impactThreshold = when (fallType) {
                FallType.LEFT, FallType.RIGHT -> 1.6
                FallType.FORWARD -> 1.5
                FallType.BACKWARD -> 1.7
                else -> IMPACT_WAIST_SV_TOT
            }

            val svdThreshold = when (fallType) {
                FallType.LEFT, FallType.RIGHT -> 1.3
                FallType.FORWARD -> 1.2
                else -> IMPACT_WAIST_SV_D
            }

            // Verificación lateral
            val lateralSpecificCheck = if (isLateralFall) {
                abs(xMaxMin[at]) > 1.8
            } else {
                false
            }

            if (impactThreshold <= svTOTAt || svdThreshold <= svDAt ||
                IMPACT_WAIST_SV_MAX_MIN <= svMaxMinAt || IMPACT_WAIST_Z_2 <= z2At ||
                lateralSpecificCheck) {

                timeoutImpact = SPAN_IMPACT
                impact[at] = 1.0
                log(android.util.Log.DEBUG, "Impact detected - Type: $fallType, svTOT: $svTOTAt, svD: $svDAt")
            }
        }

        lying[at] = 0.0
        if (0 == timeoutImpact) {
            // Evitar alertas repetidas (mínimo 10 segundos entre alertas)
            val currentTime = System.currentTimeMillis()
            if (currentTime - lastFallAlertTime < 10000) {
                log(android.util.Log.DEBUG, "Skipping alert - too soon after last alert")
                return
            }

            captureOrientation(false)

            val orientationChanged = isOrientationChanged()
            val isHorizontal = isInHorizontalPosition()
            val isVertical = isInVerticalPosition()
            val fallType = detectFallType()

            // Verificar patrón específico del bolsillo
            val isPocketPattern = checkPocketPattern()

            log(android.util.Log.DEBUG, "Fall check - Orient: $orientationChanged, Horiz: $isHorizontal, Vert: $isVertical, Type: $fallType, Peak: $peakAcceleration")

            // No confirmar caída si el dispositivo terminó en posición vertical (bolsillo)
            if (isVertical) {
                log(android.util.Log.DEBUG, "Device ended vertical - likely pocket movement, not a fall")
                // Resetear variables
                peakAcceleration = 0.0
                consecutiveLowSVCount = 0
                return
            }

            // Confirmar caída: cambio de orientación O posición horizontal
            // Y no es patrón de bolsillo
            if ((orientationChanged || isHorizontal) && !isPocketPattern) {
                lying[at] = 1.0
                lastFallAlertTime = currentTime
                val context = this.context
                if (context != null) {
                    val fallReason = when {
                        isHorizontal -> "horizontal position"
                        fallType != FallType.UNKNOWN -> "fall type: $fallType"
                        else -> "orientation change"
                    }
                    Guardian.say(context, android.util.Log.WARN, TAG, "Detected a fall - Reason: $fallReason")
                    showFallAlert(context)
                }
            }

            // Resetear variables
            peakAcceleration = 0.0
            consecutiveLowSVCount = 0
        }
    }

    // Android sampling is irregular, thus the signal is (linearly) resampled at 50 Hz
    private fun resample(postTime: Long, postX: Double, postY: Double, postZ: Double) {
        if (0L == anteTime) {
            regular = postTime + INTERVAL_MS
            return
        }
        while (regular < postTime) {
            val at: Int = buffers.position
            x[at] = linear(anteTime, anteX, postTime, postX, regular)
            y[at] = linear(anteTime, anteY, postTime, postY, regular)
            z[at] = linear(anteTime, anteZ, postTime, postZ, regular)
            process()
            buffers.position = (buffers.position + 1) % N
            regular += INTERVAL_MS
        }
    }

    private fun protect(postTime: Long, postX: Double, postY: Double, postZ: Double) {
        synchronized(buffers) {
            resample(postTime, postX, postY, postZ)
        }
    }

    override fun onAccuracyChanged(sensor: Sensor, accuracy: Int) {
        if (Sensor.TYPE_ACCELEROMETER == sensor.type) {
            log(android.util.Log.INFO, "Accuracy of the accelerometer is now equal to $accuracy")
        }
    }

    override fun onSensorChanged(event: SensorEvent) {
        if (Sensor.TYPE_ACCELEROMETER == event.sensor.type) {
            val postTime: Long = event.timestamp / 1000000
            val postX = event.values[0].toDouble() / SensorManager.STANDARD_GRAVITY
            val postY = event.values[1].toDouble() / SensorManager.STANDARD_GRAVITY
            val postZ = event.values[2].toDouble() / SensorManager.STANDARD_GRAVITY
            protect(postTime, postX, postY, postZ)
            anteTime = postTime
            anteX = postX
            anteY = postY
            anteZ = postZ
        }
    }

    private fun initiateSensor(context: Guardian) {
        this.context = context
        val manager: SensorManager = context.getSystemService(SENSOR_SERVICE) as SensorManager
        val sensor: Sensor = manager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER)
        val vendor: String = sensor.vendor
        val name: String = sensor.name
        val delay: Int = sensor.minDelay
        val resolution: Float = sensor.resolution
        log(android.util.Log.INFO, "Sensor: $vendor, $name, $delay [us], $resolution")
        manager.registerListener(this, sensor, INTERVAL_MS * 1000)
    }

    private fun captureOrientation(before: Boolean) {
        var sumX = 0.0
        var sumY = 0.0
        var sumZ = 0.0
        var count = 0.0
        for (i in 0 until SPAN_AVERAGING) {
            val xVal = at(xLPF, buffers.position - i, N)
            val yVal = at(yLPF, buffers.position - i, N)
            val zVal = at(zLPF, buffers.position - i, N)
            if (!xVal.isNaN() && !yVal.isNaN() && !zVal.isNaN()) {
                sumX += xVal
                sumY += yVal
                sumZ += zVal
                count++
            }
        }
        val orientation = Triple(sumX / count, sumY / count, sumZ / count)

        if (before) {
            beforeFallOrientation = orientation
            beforeInclinationAngle = calculateInclinationAngle(orientation)
        } else {
            afterFallOrientation = orientation
            afterInclinationAngle = calculateInclinationAngle(orientation)
        }
    }

    private fun calculateInclinationAngle(orientation: Triple<Double, Double, Double>): Double {
        // Calcular el ángulo respecto a la vertical
        val magnitude = Math.sqrt(
            orientation.first * orientation.first +
                    orientation.second * orientation.second +
                    orientation.third * orientation.third
        )

        // Evitar división por cero
        if (magnitude == 0.0) return 0.0

        // Calcular el ángulo en radianes (0 = vertical, π/2 = horizontal)
        return Math.acos(orientation.third / magnitude)
    }

    internal fun isOrientationChanged(): Boolean {
        val before = beforeFallOrientation
        val after = afterFallOrientation
        val beforeAngle = beforeInclinationAngle
        val afterAngle = afterInclinationAngle

        if (before == null || after == null || beforeAngle == null || afterAngle == null) {
            return false
        }

        val dx = Math.abs(before.first - after.first)
        val dy = Math.abs(before.second - after.second)
        val dz = Math.abs(before.third - after.third)

        // Detectar tipo de cambio
        val isLateralChange = dx > dy && dx > dz
        val isForwardBackwardChange = dy > dx && dy > dz

        // Ajustar umbrales según el tipo de cambio
        val threshold = when {
            isLateralChange -> 0.3  // Más sensible para caídas laterales
            isForwardBackwardChange -> 0.4
            else -> ORIENTATION_THRESHOLD
        }

        // Calcular cambio en el ángulo de inclinación
        val angleChange = Math.abs(beforeAngle - afterAngle)
        val angleChangeDegrees = Math.toDegrees(angleChange)

        // Ser más sensible a caídas laterales
        val angleThreshold = when {
            isLateralChange -> 20.0  // Menor umbral para caídas laterales
            isForwardBackwardChange -> 25.0
            else -> 30.0
        }

        // Calcular cambio total como magnitud vectorial
        val totalChange = Math.sqrt(dx*dx + dy*dy + dz*dz)

        // Log para debugging
        log(android.util.Log.DEBUG, "Orientation change - dx: $dx, dy: $dy, dz: $dz")
        log(android.util.Log.DEBUG, "Total change: $totalChange, Angle change: $angleChangeDegrees degrees")
        log(android.util.Log.DEBUG, "Is lateral change: $isLateralChange")

        return (dx > threshold ||
                dy > threshold ||
                dz > threshold ||
                angleChangeDegrees > angleThreshold ||
                totalChange > 0.7)  // Cambio total significativo (más sensible)
    }

    private fun isInVerticalPosition(): Boolean {
        // Verificar si el dispositivo está en posición vertical (típico del bolsillo)
        // Puede estar con USB arriba (Y positivo) o USB abajo (Y negativo)
        var sumZ = 0.0
        var sumX = 0.0
        var sumY = 0.0
        var count = 0

        for (i in 0 until SPAN_AVERAGING) {
            val zVal = at(zLPF, buffers.position - i, N)
            val xVal = at(xLPF, buffers.position - i, N)
            val yVal = at(yLPF, buffers.position - i, N)
            if (!zVal.isNaN() && !xVal.isNaN() && !yVal.isNaN()) {
                sumZ += zVal
                sumX += xVal
                sumY += yVal
                count++
            }
        }

        if (count == 0) return false

        val avgZ = sumZ / count
        val avgX = sumX / count
        val avgY = sumY / count

        // Usar valores absolutos para X y Z, pero mantener el signo de Y
        val absZ = abs(avgZ)
        val absX = abs(avgX)
        val absY = abs(avgY)  // Valor absoluto de Y para comparación

        // En posición vertical (dispositivo de pie):
        // - Y es dominante (gravedad actúa principalmente en Y, positivo o negativo)
        // - X y Z son bajos
        // Esto es típico cuando el teléfono está en el bolsillo
        val isVertical = absY > 0.75 && absX < 0.5 && absZ < 0.5

        if (isVertical) {
            val orientation = if (avgY > 0) "USB up" else "USB down"
            log(android.util.Log.DEBUG, "Device is in vertical position ($orientation) - Y: $avgY, X: $avgX, Z: $avgZ")
        }

        return isVertical
    }

    private fun checkPocketPattern(): Boolean {
        // Primero verificar si está en posición vertical
        if (isInVerticalPosition()) {
            log(android.util.Log.DEBUG, "Pocket pattern detected - device is vertical")
            return true
        }

        // Patrones típicos al meter en el bolsillo:
        // 1. Duración corta (menos de 600ms)
        // 2. No hay caída libre real prolongada
        // 3. Movimiento predominantemente en un eje
        // 4. Patrón de aceleración-desaceleración suave

        val duration = System.currentTimeMillis() - fallStartTime
        if (duration < 600) {
            log(android.util.Log.DEBUG, "Potential pocket pattern - short duration: $duration ms")
            return true
        }

        // Verificar si el movimiento fue predominantemente en un solo eje
        val at = buffers.position
        var xChange = 0.0
        var yChange = 0.0
        var zChange = 0.0

        for (i in 0 until 20) { // Últimos 400ms
            val idx = (at - i + N) % N
            xChange += abs(x[idx] - x[(idx - 1 + N) % N])
            yChange += abs(y[idx] - y[(idx - 1 + N) % N])
            zChange += abs(z[idx] - z[(idx - 1 + N) % N])
        }

        val totalChange = xChange + yChange + zChange
        val xRatio = xChange / totalChange
        val yRatio = yChange / totalChange
        val zRatio = zChange / totalChange

        // Si un eje domina más del 60%, es probablemente un movimiento controlado
        if (xRatio > 0.7 || yRatio > 0.7 || zRatio > 0.7) {
            log(android.util.Log.DEBUG, "Potential pocket pattern - single axis dominance")
            return true
        }

        return false
    }

    private fun showFallAlert(context: Context) {
        // Inicia la Activity de alerta por caída
        FallAlertActivity.start(context)
    }
}